<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; background-color: black }
			canvas { width: 100%; height: 100% }
		</style>


		<script id="vertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif

			uniform vec2 resolution;
			uniform float time;
			uniform vec2 mouse;

			float PI  = 3.141592653589793;
			float TWO_PI = 6.283185307179586;

			float slices = 12.0;
			float segments = 10.0;
			float noise_disp = 10.0;


			float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
			vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
			vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

			float noise(in vec3 p){
			    vec3 a = floor(p);
			    vec3 d = p - a;
			    d = d * d * (3.0 - 2.0 * d);

			    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			    vec4 k1 = perm(b.xyxy);
			    vec4 k2 = perm(k1.xyxy + b.zzww);

			    vec4 c = k2 + a.zzzz;
			    vec4 k3 = perm(c);
			    vec4 k4 = perm(c + 1.0);

			    vec4 o1 = fract(k3 * (1.0 / 41.0));
			    vec4 o2 = fract(k4 * (1.0 / 41.0));

			    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

			    return o4.y * d.y + o4.x * (1.0 - d.y);
			}


			vec2 getPolar(in vec2 p) 
			{
				//convert to polar 		
				return vec2( length(p)*2.0 , atan(p.y,p.x));
			}

			float radialNoise(float pheta, float r, float segs ) //returns a radial noise field
			{
				//normalised angle
    			float na = pheta/TWO_PI;
    			na += 0.4999999;

    			//quantised angle
    			float i = floor(na * segs)/segs;
				float ni = mod(i + 1.0/segs, 1.0);
				float f = fract(na * segs); //how much to interpolate

				//get the current step
				float ri = noise(vec3(i * noise_disp, time + sin(pheta), r)); 

				//get the next step
				float rni = noise(vec3(ni * noise_disp, time + sin(pheta), r)); 

				//radial interpolated noise 
				float noise_i = mix(ri, rni, smoothstep(0.0, 1.0, f)); //interpolation for angle

				return noise_i;
			}


			
			void main()	{
				

				//normalised coordinates
				vec2 pos =  gl_FragCoord.xy * 2.0 / resolution.x;
				pos.x -= 1.0;
				pos.y -= resolution.y * 1.0/resolution.x;
				
				vec2 polPos = getPolar(pos);

				//normalised angle
    			float nangle = polPos.y/TWO_PI;
    			nangle += 0.4999999;

				float noise_i = radialNoise(polPos.y, polPos.x, slices);
				noise_i = noise_i * 0.5 + 0.5;


				float lum_i = smoothstep( 0.1 + noise_i , 0.07 + noise_i , polPos.x); //threshold for the edge
				float lum = noise_i * lum_i; //mix with radial noise

				float segment = floor(segments* polPos.x/noise_i); //determine which segment

				//make normalised coordinates for the segment
				vec2 tex = vec2(fract(nangle * slices + noise_i), fract(segments * polPos.x/noise_i)); 

				tex.x *= (segment + 1.0); //tile x-wise according to segement
				tex = fract(tex);

				float cell = 1.0 - distance(tex, vec2(0.5,0.5)); //shade
				vec3 col = vec3(1.0, 0.5, 0.5);

				gl_FragColor = vec4(vec3(cell * lum) * col,1.0);
				//gl_FragColor = vec4(vec3(noise_i),1.0);

			}

		</script>

	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript" src="main.js"></script>
	</body>
</html>