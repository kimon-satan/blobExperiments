<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; background-color: black }
			canvas { width: 100%; height: 100% }
		</style>


		<script id="vertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform float time;

			float PI  = 3.141592653589793;
			float TWO_PI = 6.283185307179586;

			float slices = 12.0;
			float segments = 10.0;
			float noise_disp = 10.0;


			//2D noise
			float random (vec2 st) {
			    return fract(sin(dot(st.xy,
			                         vec2(12.9898,78.233)))*
			        43758.5453123);
			}

			//1D noise function
			float random (float x)
			{
				return fract(sin(x)* 43758.5453123);
			}

			float noise (in vec2 st) {
			    vec2 i = floor(st);
			    vec2 f = fract(st);

			    // Four corners in 2D of a tile
			    float a = random(i);
			    float b = random(i + vec2(1.0, 0.0));
			    float c = random(i + vec2(0.0, 1.0));
			    float d = random(i + vec2(1.0, 1.0));

			    // Smooth Interpolation

			    // Cubic Hermine Curve.  Same as SmoothStep()
			    vec2 u = f*f*(3.0-2.0*f);
			    // u = smoothstep(0.,1.,f);

			    // Mix 4 coorners porcentages
			    return mix(a, b, u.x) + 
			            (c - a)* u.y * (1.0 - u.x) + 
			            (d - b) * u.x * u.y;
			}
			
			void main()	{
				
				//quantise time
				float ts = time * 0.001;

				//normalised coordinates
				vec2 pos =  gl_FragCoord.xy * 2.0 / resolution.x;
				pos.x -= 1.0;
				pos.y -= resolution.y * 1.0/resolution.x;
				
				//convert to polar 
				float r = length(pos)*2.0;
    			float angle = atan(pos.y,pos.x);

    			//normalised angle
    			float nangle = angle/TWO_PI;
    			nangle += 0.4999999;
				
    			//quantised angle
    			float i = floor(nangle * slices)/slices;
				float ni = mod(i + 1.0/slices, 1.0);
				float f = fract(nangle * slices); //how much to interpolate

				float displace = sin(angle);
				//get the current step
				float ri = noise(vec2(i * noise_disp, ts + displace)); //use sin of angle for avoiding block changes

				//get the next step
				float rni = noise(vec2(ni * noise_disp,ts + displace)); 
			
				//radial interpolated noise 
				float noise_i = mix(ri, rni, smoothstep(0.,1.,f)); //interpolation for angle
				noise_i = 0.5 + noise_i * 0.5; //squash range to 0.5 -> 1.0

				float lum_i = smoothstep( 0.1 + noise_i , 0.07 + noise_i , r); //threshold for the edge
				float lum = noise_i * lum_i; //mix with radial noise

				float segment = floor(segments * r/noise_i); //determine which segment

				//make normalised coordinates for the segment
				vec2 tex = vec2(fract(nangle * slices + noise_i), fract(segments * r/noise_i)); 

				tex.x *= (segment + 1.0); //tile x-wise according to segement
				tex = fract(tex);

				float cell = 1.0 - distance(tex, vec2(0.5,0.5)); //shade
				vec3 col = vec3(1.0, 0.5, 0.5);

				gl_FragColor = vec4(vec3(cell * lum) * col,1.0);


			}

		</script>

	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript" src="main.js"></script>
	</body>
</html>