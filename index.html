<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; background-color: black }
			canvas { width: 100%; height: 100% }
		</style>


		<script id="vertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform vec2 resolution;
			uniform float time;
			uniform vec2 mouse;

			float PI  = 3.141592653589793;
			float TWO_PI = 6.283185307179586;

			float slices = 12.0;
			float segments = 10.0;
			float noise_disp = 10.0;
			float ts = 0.0;


			//2D noise
			float random (vec2 st) {
			    return fract(sin(dot(st.xy,
			                         vec2(12.9898,78.233)))*
			        43758.5453123);
			}

			//1D noise function
			float random (float x)
			{
				return fract(sin(x)* 43758.5453123);
			}

			float noise (in vec2 st) {
			    vec2 i = floor(st);
			    vec2 f = fract(st);

			    // Four corners in 2D of a tile
			    float a = random(i);
			    float b = random(i + vec2(1.0, 0.0));
			    float c = random(i + vec2(0.0, 1.0));
			    float d = random(i + vec2(1.0, 1.0));

			    // Smooth Interpolation
			    // Cubic Hermine Curve.
			    vec2 u = smoothstep(0.,1.,f);

			    // Mix 4 corners percentages
			    return mix(a, b, u.x) + 
			            (c - a)* u.y * (1.0 - u.x) + 
			            (d - b) * u.x * u.y;
			}

			vec2 getPolar(in vec2 p) 
			{
				//convert to polar 		
				return vec2( length(p)*2.0 , atan(p.y,p.x));
			}

			float getRadialNoise(in vec2 p) //radius not used
			{
				//normalised angle
    			float na = p.y/TWO_PI;
    			na += 0.4999999;
				
    			//quantised angle
    			float i = floor(na * slices)/slices;
				float ni = mod(i + 1.0/slices, 1.0);
				float f = fract(na * slices); //how much to interpolate

				//get the current step
				float ri = noise(vec2(i * noise_disp, ts + sin(i))); //use sin of angle for avoiding block changes

				//get the next step
				float rni = noise(vec2(ni * noise_disp,ts + sin(ni))); 

			
				//radial interpolated noise 
				float noise_i = mix(ri, rni, smoothstep(0.,1.,f)); //interpolation for angle
				noise_i = mix(noise_i, noise(vec2(sin(p.y), ts + sin(p.y))), 0.25);
				noise_i = 0.5 + noise_i * 0.5; //squash range to 0.5 -> 1.0


				return noise_i;
			}


			
			void main()	{
				
				//quantise time
				ts = time * 0.001;
				//normalised coordinates
				vec2 pos =  gl_FragCoord.xy * 2.0 / resolution.x;
				pos.x -= 1.0;
				pos.y -= resolution.y * 1.0/resolution.x;
				
				vec2 polPos = getPolar(pos);
				vec2 dPolPos = getPolar(pos + vec2(sin(ts) * 0.05, cos(ts) * 0.05));

				//normalised angle
    			float nangle = polPos.y/TWO_PI;
    			nangle += 0.4999999;

				float noise_i = getRadialNoise(polPos);


				float lum_i = smoothstep( 0.1 + noise_i , 0.07 + noise_i , polPos.x); //threshold for the edge
				float lum = noise_i * lum_i; //mix with radial noise

				float segment = floor(segments * polPos.x/noise_i); //determine which segment

				//make normalised coordinates for the segment
				vec2 tex = vec2(fract(nangle * slices + noise_i), fract(segments * polPos.x/noise_i)); 

				tex.x *= (segment + 1.0); //tile x-wise according to segement
				tex = fract(tex);

				float cell = 1.0 - distance(tex, vec2(0.5,0.5)); //shade
				vec3 col = vec3(1.0, 0.5, 0.5);

				gl_FragColor = vec4(vec3(cell * lum) * col,1.0);


			}

		</script>

	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript" src="main.js"></script>
	</body>
</html>