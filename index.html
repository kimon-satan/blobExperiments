<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Blob</title>
		<style>
			body { margin: 0; background-color: black }
			canvas { width: 100%; height: 100% }
		</style>


		<script id="vertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif


			uniform vec2 resolution;
			uniform float time;
			uniform vec2 mouse;

			float PI  = 3.141592653589793;
			float TWO_PI = 6.283185307179586;

			//characteristics

			float scale = 2.0;
			float slices = 8.0; //theta wise repeat (outer only)
			float segments = 1.0; //rho wise repeat
			float c_size = 0.5; //proportional size of center
			float o_amp = 0.1; //amp of noise
			float o_step = 20.; //the noise step of the outer edge
			float c_amp = 0.1; 
			float theta_warp = 1.5;
			vec2 move_distort = vec2(.4, 2.); //for irregular acceleration
			float move_mul = .5;
			float move_add = .5;
			float move_freq = 2.;


			///////////////////////////////////TEXTURE FUNCTIONS//////////////////////////////////////

			float drawShape(in vec2 p){
            
            	// Wrappable circle distance. The squared distance, to be more precise.
            	p = fract(p) - 0.5;    
            	return dot(p, p); 
            
        	}

        	float cellTex(in vec2 p){   
            
         
	            float c = 1.0; // Set the maximum, bearing in mind that it is multiplied by 4.
	            
	            // Draw four overlapping shapes (circles, in this case) using the darken blend 
	            // at various positions on the tile

				c = min(c, drawShape(p - vec2(.14 , .32)));
		        c = min(c, drawShape(p - vec2(.8, .80)));
		        
		        c = min(c, drawShape(p - vec2(.16, .11 )));
		        c = min(c, drawShape(p - vec2(.5, .50)));
		    
		        // Draw four smaller circles at various positions on the tile.
		        
		        p *= 1.4142; 
		        
		        c = min(c, drawShape(p - vec2(.39, .10)));
		        c = min(c, drawShape(p - vec2(.20, .63))); 
		        
		        // More shapes produce a more convincing pattern, but you could cut
		        // these two out and still produce a decent image.
		        c = min(c, drawShape(p - vec2(.40, .30)));
		        c = min(c, drawShape(p - vec2(.80, .90)));  
	            
	            return sqrt(c*4.);
            
        	}

        	vec3 tex2D(vec2 p){
            
	            float c = cellTex(p);
	        	//vec3 col = vec3(c, c * c*   .5, c *c*  .5) + (cellTex(p*2.))*.05 - .025; // Bio green.
	            vec3 col = vec3(c*c, c*sqrt(c), c) + (cellTex(p*6.))*.05 - .025; // Blueish.

	            col = clamp(col, 0., 1.);
	            // Sinusoidally mixing in a complimentary color, of sorts, for a bit of variance.
	            return mix(col, col.yzx, dot(sin(p*12. - sin(p.yx*12. + c*6.283)), vec2(.5))*.15 + .15);
	            return col;
        	}

        	///////////////////////////////////NOISE FUNCTIONS///////////////////////////////////

			float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
			vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
			vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

			float noise(in vec3 p){
			    vec3 a = floor(p);
			    vec3 d = p - a;
			    d = d * d * (3.0 - 2.0 * d);

			    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			    vec4 k1 = perm(b.xyxy);
			    vec4 k2 = perm(k1.xyxy + b.zzww);

			    vec4 c = k2 + a.zzzz;
			    vec4 k3 = perm(c);
			    vec4 k4 = perm(c + 1.0);

			    vec4 o1 = fract(k3 * (1.0 / 41.0));
			    vec4 o2 = fract(k4 * (1.0 / 41.0));

			    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

			    return o4.y * d.y + o4.x * (1.0 - d.y);
			}

			///////////////////////////////////OTHER HELPERS///////////////////////////////////

			mat2 rotate2d(float _angle){
			    return mat2(cos(_angle),-sin(_angle),
			                sin(_angle),cos(_angle));
			}

			
			void main()	{


				//generate normalised coordinates

				vec2 trans = vec2(2.0, resolution.y * 2.0/ resolution.x) * scale;

				vec2 pos = ( gl_FragCoord.xy / resolution.xy ) - 0.5;
				pos *= trans;

				vec2 center = vec2(0.);

				//FOR DEBUGGING WITH MOUSE
				/*
				vec2 mouseP = mouse - .5;
				mouseP *= trans;
				mouseP.y *= -1.;
				
				float cp = 1.0 - step(0.02, distance(pos , mouseP));
				float mp = 1.0 - step(0.02, distance(pos , center));
				vec3 markers = vec3(0., cp,  0.) + vec3(mp,0., 0.);

				*/

				//rotate the coordinate space around the center
				pos = rotate2d(PI/2.) * pos;

				//get polar coordinates
				float theta = atan(pos.y, pos.x);
				float rho = distance(pos, center); 

				//unsigned angle for symmetry
    			float ustheta = abs(theta / TWO_PI);
    			float ustheta2 = pow(ustheta, theta_warp); //a bit of shaping to squash towards the bottom

    			float n_rho = clamp(rho, 0., 1.); //clamp the rho

    			float right_field = min( 0., cos(theta + PI/2.0)); // a distance field on the right only

    			float asymmetry = .5;

    			vec2 move = (vec2(sin(time * move_freq), cos(time * move_freq)) + 1.)/2.;
    			move.x = pow(move.x, move_distort.x) + right_field * asymmetry; // a time delay for the right hand side
    			move.y = pow(move.y, move_distort.y);
    			move = move * move_mul + move_add;

    			float o_noise = noise(vec3(ustheta2 * o_step * move.x , ustheta2 * o_step * move.y , 0.)); //symmetrical noise
    			float c_noise = noise(vec3(cos(theta) + time, sin(theta) + time , 0.));
    			
    			//edges
    			float o_edge = 1. - o_amp * o_noise; 
    			float c_edge = c_size - c_amp * c_size * c_noise; 

    			//masks with judicious blending for no gaps
    			float o_lum =  1.0 - smoothstep(o_edge - 0.1, o_edge , n_rho); 
    			float c_lum = 1.0 - smoothstep(c_edge - 0.1, c_edge , n_rho); 
    			

    			float o_nrho = clamp((n_rho - c_edge)/(o_edge - c_edge), 0., 1.);
    			vec3 o_col = tex2D(vec2(o_nrho * segments, ustheta2 * slices)); //texturing 

				float c_nrho = n_rho/c_edge;    			
    			vec3 c_col = tex2D(vec2(cos(theta) * c_nrho * segments, sin(theta) * c_nrho * segments));
    			
    			//NB. currently using same segments for inner and outer .. this might be changed
				
				gl_FragColor = vec4( vec3(o_col * o_lum * (1.0 - c_lum) + c_lum * c_col),1.0);
				

			}

		</script>

	</head>
	<body>
		<script src="three.min.js"></script>
		<script type="text/javascript" src="main.js"></script>
	</body>
</html>